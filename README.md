# Дрессируем своего питона, pre-alpha v0.01
фор енбисус виз :heart:

## Soderzhanie

0. [zsh + ohmyzsh](#optional-zsh-terminal)
1. [pyenv](#pyenv)
    1. [Устанавливаем Pyenv](#install-pyenv)
    1. [Апгрейдим Pyenv](#upgrade-pyenv)
    1. [Используем Pyenv](#use-pyenv)
    1. [pyenv-virtualenv / pyenv-virtualenvwrapper](#pyenv-virtualenv-/-pyenv-virtualenvwrapper)
1. [Пакуем виртуальную среду]()
1. [Docker]()
<hr>


Сегодня мы займемся здоровьем своего змiя. Потому что те гигиенически неприемлемые условия, в которых он содержится, несколько кореллируют с тем, насколько ему херово. Совпадение? Не думаю.

Что мы хотим юзать?
* pyenv
* virtualenv
* pyenv-virtualenv / pyenv-virtualenvwrapper, если ~~слабак~~ хочется, чтобы красиво и легко

Да и всё, вообще-то. Дальше как бы в виде расширения ниже будет инструкция с поднятием этого же добра, но под более кошерное окружение терминала, но это уже потом, если захотите. Спойлер: лучше захотите, zsh очень приятный.


# (Optional) zsh terminal
Как я уже говорил, zsh милашечка. Из фичей своих этих башей вы ничего не потеряете, только кучу приятных мелочей по дефолту получите. Не хотите использовать - whatever, вам тогда [сюда, к установке Pyenv](#pyenv). Тех же, кто захочет приобщиться к прекрасному - прошу нежно и аккуратно листать вниз.

## Зачем zsh?
*   автодополнение _по дефолту_ (да, я знаю, что в баше тоже есть, но оно стороннее и кривое)
*  кошерно-душевные плагины
* могёт в человеческие массивы всякие
* нормально обрабатывает многострочные команды
* делит историю команд между всеми экземплярами оболочек по отдельности
* кайфовые alias по дефолту, к которым привыкаешь моментально
* ну и прочая фигня, типа максмальной кастомизируемости, темок и всяких свистоперделок
* спойлер: есть еще такая штука, [oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh), фреймворк для конфигов zsh, ну и с ним вообще чума, но про него попозже

> *нО мНе и С бАШоМ нОмАНа РаБОтАетСя зАчЕм МнЕ МеНятЬ?7?7?*

Не хочешь - не меняй. zsh удобен, я уже сказал, дальше - как хочешь.
<hr>

## Установочка zsh
 Вы не поверите.
 ```
 sudo apt-get install zsh
 ```
 Ну и проверьте, что всё ок
 ```
 zsh --version
 ```
 Ожидается что-то вроде
 ```
zsh 5.1.1 (x86_64-ubuntu-linux-gnu)
```


## Делаем zsh дефолтным шеллом
```
chsh -s $(which zsh)
```
По виндовским чертежам фиксим мироздание через логаут&логин. Серьезно, прям полностью, просто шелл перезапустить - не вариант.

Если на старте zsh будет просить вас выбрать конфиг - создавайте пустой. Этот наш конфиг все равно потом будет переписан автоматически через oh my zsh.

Как закончили - проверяем используемый шелл.
```
echo $SHELL && $SHELL --version 
```
Ну и вернуться должно что-то такое
```
/usr/bin/zsh
zsh 5.1.1 (x86_64-ubuntu-linux-gnu)
```
<hr>

## Бахаем Oh My Zsh!
 Ну тут два варианта, выбирайте тот, который вам больше по религии:

 1. Через curl
 ```
 sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"
 ```
 2. Через wget
 ```
 sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"
 ```
 Разницы никакой.

 Дальше создавайте дефолтный конфиг и будет вам всё намана.

 

 <hr>

 ## Свистоперделки для oh my zsh

 Основная настройка всего и всякого для ohmyzsh находится все еще в конфиге самого zsh, то есть в `~/.zshrc`.

### Темочки

Для начала, полюбуемся на темочки. Есть короч гигантский список тем, все различаются чуть более, чем полностью, так что сами смотрите, что вам прикольнее. Мне нравится `agnoster`, поэтому я себе в конфиге прописал магическую строчку `ZSH_THEME="agnoster"` и, омагад, моя тема стала `agnoster`. Анбиливабал. 

Если не вкатили эти темы, возможно, стоит попробовать темы [Powerlevel9k](https://github.com/bhilburn/powerlevel9k) к непосредственно zsh. Они тоже очень приятные, рекомендую. Куча самых разных конфигов для него [тут](https://github.com/bhilburn/powerlevel9k/wiki/Show-Off-Your-Config). Ну или сами делайте.

Не забываем, кстати, еще про всякие кастомные шрифты и все такое, когда пользуемся темами дополнительными, всякие гитхабовские значки и все такое из ниоткуда не возьмутся. Если по непонятным причинам у вас все еще не установлен [powerline](https://github.com/powerline/fonts), вероятно, стоит его установить. Надеюсь, с одной командой вида `apt-get install` вы как-нибудь справитесь.

### Плагинчики

Есть короче такая тема, что можно себе набрать охапку всяких плагинов и сидеть с ними, как в бункере. Ставятся они либо через просто настройку в `~/.zshrc` в разделе `plugins=()` (если они дефолтные и идут вместе с oh my zsh), либо ставятся через git в папку `~/.oh-my-zsh/plugins` (если они не включены по дефолту в oh my zsh).

Вот списочек, который юзаю я:
```
plugins=(
  git
  colored-man-pages
  zsh-syntax-highlighting
  zsh-autosuggestions
)
```
Гит - понятно, цветные маны - понятно, syntax highlighting кошерный, потому что когда пишется что-то косячно, zsh заботливо подсвечивает команду красным, autosuggestions - довольно страшная на первый взгляд штука, но крайне удобная, если приходится часто делать одно и то же действие. Предлагает ранее выполненные команды в качестве предложения на нынешнее введенное в терминал. Чтобы заполнить автопредложенной командой, тыкните стрелочку вправо. Такие дела.

Если хочется обмазаться плагинами и найти самое-самое для себя, то это можно здесь сделать [здесь](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins). Аллах тебе в помощь.

А еще у zsh **К У Ч А** ништяковых alias. Прочекай их, введя `alias`. Там 228 биндов на гит, но это для задротов, есть и нормальные. Чего только стоят всякие фишки с `d` для вывода последних папок и `цифра_этой_папки_в_списке` для перехода в неё. Всякие `....` вместо `../../..` - эт дефолт уже. Ну и так далее. Крутяк же.

Такие дела.

## !!! CUDA !!!

А, если будут проблемы со всякими CUDA и тосибоси - извините, просто у zsh намного более удобный синтаксис, чем у bash, поэтому и модификация `$PATH` всяких выглядит чуть-чуть по-другому.

Добавьте в конец `~/.zshrc`:
```
export PATH=/usr/local/cuda/bin:$PATH
export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH
```


[вернуться к содержанию](#soderzhanie)
<hr>

Ну вроде с фигней всякой разобрались, теперь можно браться непосредственно за само питоновское окружение.

Начнем с pyenv.
# Pyenv

> pyenv lets you easily switch between multiple versions of Python. It's simple, unobtrusive, and follows the UNIX tradition of single-purpose tools that do one thing well.

Если по-православному, то pyenv регулирует версии питона в ваших этих юнексах. Это прикольно, потому что вам не придется компилить с сорцов пайтон 3.6 под Ubuntu 16-ую и все такое. Вместо этого вы получаете возможность управлять версиями питончика, при этом:
1. Можно менять глобальную версию питона для использования по дефолту _для каждого пользователя отдельно_ (то есть, Никитос взял такой запилил себе по дефолту 2.7.12 по хардкору, а я хипстер и хочу вообще себе по дефолту у него 3.8 из dev ветки, у каждого из нас свой глобальный питон (который вызывается в шелле через `python`) и у нас всё Н А М А Н А)
1. Можно ставить много версий питона внутри одного пользователя, например, под каждый проект свою версию питона, если так хочется
1. Можно заоверрайдить системную версию питона через переменную окружения, то есть легко, просто и без изнасилований системного питона (передаем привет перекомпиленным сорцам)
1. Ну и кроме того, pyenv не делает некоторых безобразий, которым подвержены другие менеджеры пресмыкающихся:
    * pyenv накатали на чистом шелле. То есть зафакапить pyenv через питон ну как-то нереально
    * его не нужно подгружать явно в шелл, он сам поднимается через указанный параметр в `$PATH`
    * этот зверь не лезет в виртуальные окружения и не насилует их каким-либо образом, он работает отдельно от них. При этом еще и помогает вам работать со своими собственными виртуальными средами через всякие няшные плагины

Круто? Круто. Вот щас и займемся тем, что будет этого красавца поднимать. Это как бы не очень сложно, но чуток покопипастить команд придется.

## install pyenv
```
ВУРНИНГ! Я бы вообще посоветовал сначала поставить zsh, а потом уже ставить всякие эти фигни, просто потому что с zsh много чего удобнее. Я как бы всё понимаю, поэтому там ниже будет вариант для пацанов с zsh, а потом для стариков с bash, но вы понимаете, к чему я агитирую.
```
Если вы совершенно случайно решили прямо сейчас поставить себе zsh, то вам [сюда](#Optional:-zsh-terminal).
<hr>

#### Готовимся пакетно к тому, чтобы прочищать желудок нашему питону:

```
sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev \
libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \
xz-utils tk-dev
```
<hr>

#### Выкачиваем pyenv с гитхабика:
```
git clone https://github.com/pyenv/pyenv.git ~/.pyenv
```
<hr>

#### Закидываем pyenv в системные переменные

zsh (чётко!):
```
$ echo 'export PYENV_ROOT="$HOME/.pyenv"' >> ~/.zshenv
$ echo 'export PATH="$PYENV_ROOT/bin:$PATH"' >> ~/.zshenv
```

bash (мда):
```
$ echo 'export PYENV_ROOT="$HOME/.pyenv"' >> ~/.bashrc
$ echo 'export PATH="$PYENV_ROOT/bin:$PATH"' >> ~/.bashrc
```
<hr>

#### Закидываемся автозаполнением и автоматической инициализацией сред

zsh (2k18):
```
echo -e 'if command -v pyenv 1>/dev/null 2>&1; then\n  eval "$(pyenv init -)"\nfi' >> ~/.zshenv
```

bash (2k18 до н.э.):
```
echo -e 'if command -v pyenv 1>/dev/null 2>&1; then\n  eval "$(pyenv init -)"\nfi' >> ~/.bashrc
```
<hr>

#### Рестартим шелл
```
exec "$SHELL"
```
<hr>

#### Пробуем ставить какой-нибудь питончик
Сейчас последний 3.6.5, так что я тут поставлю 3.6.5. Хочешь - ставь другой, мне пофигу. Ставиться это добро будет в `$(pyenv root)/versions`, если что.
```
pyenv install 3.6.5
```


???????????

PROFIT
<hr>

#### А если я хочу заапгрейдить pyenv?

Специально для тебя, пупсик:
### UPGRADE PYENV
```
cd $(pyenv root)
git pull
```
<hr>

## Use Pyenv

С использованием все просто. Напрямую Pyenv вам придется использовать не так уж и часто.

### Установить пользователю другую версию питона:
`pyenv install X.Y.Z` установит питончик версии X.Y.Z
<br>
<br>

### Поменять глобальную версию питона:
`pyenv global X.Y.Z` поменяет питон на версию X.Y.Z при вызове обычного `python` в системе
<br>
<br>

### Поменять вызываемую версию питона в какой-то отдельно взятой папке:
`pyenv local nameofvenv` создаст файл `.python-version`, куда запишет `nameofvenv`. По дефолту pyenv ищет по папке файл `.python-version`, и если находит его, подгружает из него название среды (или версию питона, whatever), которую он должен активировать, ну и активирует. Никаких `source activate nameofvenv` не надо (это задел на далекое прекрасное будущее с виртуальными средами, watch closely).
<br>
<hr>

## pyenv-virtualenv / pyenv-virtualenvwrapper

Я очень надеюсь, что вы хотя бы слышали, что такое virtualenv/virtualenvwrapper. Ну ладно, virtualenv вы точно знаете,  а virtualenvwrapper - это просто обертка на virtualenv с быстрыми командами для создания, удаления и всевозможного менеджмента виртуальных сред. Хрень, если честно, потому что поднимать эти среды надо максимум раз в месяц, но если хотите - вы меня поняли.

Я предпочитаю поставить один только virtualenv для управления средами совместно с версиями питона от Pyenv и радоваться жизни.

<hr>

### install
Ставиться всё это добро будет в `$(pyenv root)/plugins/pyenv-virtualenv`

Клонируем репозиторий с этим добром:
```
git clone https://github.com/pyenv/pyenv-virtualenv.git $(pyenv root)/plugins/pyenv-virtualenv
```

Закидываем в конфиг терминала параметр для автоподнятия сред по определенным папкам (как обычно, есть версия для лохов и версия для пацанов):

zsh (чума):
```
echo 'eval "$(pyenv virtualenv-init -)"' >> ~/.zshenv
```

bash (кек):
```
echo 'eval "$(pyenv virtualenv-init -)"' >> ~/.bashrc
```

Рестартим и обнаруживаем, что всё по каефу.
<hr>

### How to use

TBD


[вернуться к содержанию](#soderzhanie)

# virtual enviroment

TBD

# Docker

TBD

# nvidia driver + CUDA

```
sudo nano /etc/modprobe.d/blacklist.conf
```
```
blacklist nouveau
blacklist lbm-nouveau
options nouveau modeset=0
alias nouveau off
alias lbm-nouveau off
```
```
sudo apt-get remove --purge nvidia-*
sudo apt-add-repository ppa:graphics-drivers/ppa
sudo apt-get update
```

```
sudo apt-get install nvidia-3??
```
